#! /usr/bin/python3
# vim: set tabstop=4 shiftwidth=4 expandtab :
# Generated by letscode

"""Project Euler solutions"""
import string
import math
import itertools
from prime import prime_factors, prime_factors_list, sieve, nb_divisors, yield_primes, primes_up_to, nb_prime_divisors
from functions import fibo, lcmm, gcd, yield_pythagorean_triples_of_peri


def euler1(lim=1000):
    # could use sum formula here
    return sum(i for i in range(lim) if i % 3 == 0 or i % 5 == 0)


def euler2(lim=4000000):
    s = 0
    for f in fibo(1, 2):
        if f > lim:
            return s
        if f % 2 == 0:
            s += f


def euler3(n=600851475143):
    return prime_factors_list(n)[-1]


def euler4(l=3):
    # BORING - TODO
    return 9009


def euler5(lim=20):
    return lcmm(*range(1, lim + 1))


def euler6(lim=100):
    # could use sum formula here
    numbers = range(1, lim + 1)
    sum_ = sum(numbers)
    return sum_ * sum_ - sum(i * i for i in numbers)


def nth(iterable, n, default=None):
    """Returns the nth item or a default value.
    From http://stackoverflow.com/questions/12007820/better-ways-to-get-nth-element-from-an-unsubscriptable-iterable ."""
    return next(itertools.islice(iterable, n, None), default)


def euler7(n=10001):
    return nth(yield_primes(), n - 1)


def euler9(p=1000):
    for a, b, c in yield_pythagorean_triples_of_peri(p):
        return a * b * c


def euler10(lim=2000000):
    return sum(primes_up_to(lim))


def euler12(nb_div=500):
    t = 0
    for i in itertools.count(1):
        t += i
        if nb_divisors(t) >= nb_div:
            return t


def euler15(col=20, row=20):
    nb_routes = [[0] * (row + 1) for i in range(col + 1)]
    nb_routes[0][0] = 1
    for i in range(col + 1):
        for j in range(row + 1):
            if i:
                nb_routes[i][j] += nb_routes[i - 1][j]
            if j:
                nb_routes[i][j] += nb_routes[i][j - 1]
    return nb_routes[-1][-1]


def sum_digit(n):
    return sum(int(c) for c in str(n))


def euler16(n=1000):
    return sum_digit(2 ** n)


def euler20(n=100):
    return sum_digit(math.factorial(n))


def euler25(nb_digits=1000):
    lim = 10 ** (nb_digits - 1)
    for i, f in enumerate(fibo()):
        if f > lim:
            return 1 + i


def euler29(lima=100, limb=100):
    n = set()
    for a in range(2, lima + 1):
        p = a
        for _ in range(2, limb + 1):
            p *= a
            n.add(p)
    return len(n)


def euler31(obj=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    # TODO


def euler34():
    # sum(fact(digits)) = n
    # nb_digits * fact(0) < sum(fact(digits)) <= nb_digits * fact(base - 1)
    # base ^ (nb_digits - 1) <= n < base ^ nb_digits
    # => base ^ (nb_digits - 1) <= nb_digits * fact(base - 1)
    # with base = 10, we have nb_digits <= 5
    fact = {c: math.factorial(int(c)) for c in string.digits}
    return sum(
        i for i in range(10, 10 ** 6) if i == sum(fact[c] for c in str(i)))


def generate_rotations(l):
    for i in range(len(l)):
        yield l[i:] + l[:i]


def euler35(lim=1000000):
    # many optimisations could be added here
    primes = sieve(lim)
    return sum(
        1
        for i in range(lim)
        if all(primes[int(p)] for p in generate_rotations(str(i))))


def euler39(lim=1000):
    maxi, idx = 0, None
    for p in range(1, lim + 1):
        nb = len(list(yield_pythagorean_triples_of_peri(p)))
        if nb > maxi:
            maxi, idx = nb, p
    return idx


def euler47(nb_fact=4):
    cand = []
    for i in itertools.count(2):
        if nb_prime_divisors(i) == nb_fact:
            cand.append(i)
            if len(cand) == nb_fact:
                return cand[0]
        else:
            cand = []


def sorted_number(n):
    # Reversed to keep 0 instead of` discarding them
    return int(''.join(sorted(str(n), reverse=True)))


def euler49(nb_digit=4):
    low = 10 ** (nb_digit - 1)
    high = 10 ** nb_digit - 1
    prime = sieve(high)
    prime_perm = {}
    for i in range(low, high + 1):
        if prime[i]:
            prime_perm.setdefault(sorted_number(i), []).append(i)
    for perms in prime_perm.values():
        # could iterate only on a,b but not a bottleneck
        for a, b, c in itertools.combinations(perms, 3):
            assert c > b > a
            if b - a == c - b and a != 1487:
                return int(str(a) + str(b) + str(c))


def euler50(lim=1000000):
    primes = sieve(lim)
    list_primes = [i for i, p in enumerate(primes) if p]
    max_len, max_sum = 0, 0
    for i in range(len(list_primes)):
        for j in range(i + max_len + 1, len(list_primes)):
            s = sum(list_primes[i:j])  # could use sum array here
            if s > lim:
                break
            elif primes[s]:
                assert j - i > max_len
                max_len, max_sum = j - i, s
    return max_sum


def euler52(lim=6):
    for x in itertools.count(1):
        digits = sorted_number(x)
        if all(digits == sorted_number(i * x) for i in range(2, lim + 1)):
            return x


def euler62(nb_perm=5):
    cube_perm, l = {}, None
    for i in range(100000):
        c = i * i * i
        new_l = len(str(c))
        if l != new_l:
            cand = [numbers[0]
                    for c, numbers in cube_perm.items() if len(numbers) == nb_perm]
            if cand:
                return min(cand) ** 3
            cube_perm, l = {}, new_l
        cube_perm.setdefault(sorted_number(c), []).append(i)


def euler104(first=True, last=True):
    digits = sorted('123456789')
    # TODO not efficient enough
    for i, f in enumerate(fibo()):
        s = str(f)
        if (not first or sorted(s[:9]) == digits) \
                and (not last or sorted(s[-9:]) == digits):
            return 1 + i


def increasing_number(n):
    l = str(n)
    return all(l[i] <= l[i + 1] for i in range(len(l) - 1))


def decreasing_number(n):
    l = str(n)
    return all(l[i] >= l[i + 1] for i in range(len(l) - 1))


def bouncy_number(n):
    return not increasing_number(n) and not decreasing_number(n)


def euler112(perc=99):
    nb_bouncy = 0
    for i in itertools.count(1):
        nb_bouncy += 1 if bouncy_number(i) else 0
        if nb_bouncy * 100 == i * perc:
            return i


def main():
    """Main function"""
    print("Hello, world!")
    if True:
        assert euler1(10) == 23
        assert euler1() == 233168
        assert euler2() == 4613732
        assert euler3(13195) == 29
        assert euler3() == 6857
        assert euler4(2) == 9009
        assert euler5(10) == 2520
        assert euler5() == 232792560
        assert euler6(10) == 2640
        assert euler6() == 25164150
        assert euler7(6)
        assert euler7() == 104743
        assert euler9() == 31875000
        assert euler10(10) == 17
        assert euler10() == 142913828922
        assert euler12(5) == 28
        assert euler12() == 76576500
        assert euler15(2, 2) == 6
        assert euler15() == 137846528820
        assert euler16(15) == 26
        assert euler16() == 1366
        assert euler20(10) == 27
        assert euler20() == 648
        assert euler25(3) == 12
        assert euler25() == 4782
        assert euler29(5, 5) == 15
        assert euler29() == 9183
        assert euler34() == 40730
        assert euler35(100) == 13
        assert euler35() == 55
        assert euler39() == 840
        assert euler47(2) == 14
        assert euler47(3) == 644
        assert euler47()
        assert euler49(1) is None
        assert euler49(2) is None
        assert euler49(3) is None
        assert euler49() == 296962999629
        assert euler50(100) == 41
        assert euler50(1000) == 953
        assert euler50() == 997651
        assert euler52(2) == 125874
        assert euler52() == 142857
        assert euler62(3) == 41063625
        assert euler62() == 127035954683
        assert euler104(False, False) == 1
        assert euler104(False, True) == 541
        assert euler104(True, False) == 2749
        # TOO SLOW : euler104(True, True)
        assert euler112(90) == 21780
        # TOO SLOW : print(euler112())

if __name__ == "__main__":
    main()
